--- === ClipboardTool ===
---
--- Keep a history of the clipboard for text entries and manage the entries with a context menu
---
--- Originally based on TextClipboardHistory.spoon by Diego Zamboni with additional functions provided by a context menu
--- and on [code by VFS](https://github.com/VFS/.hammerspoon/blob/master/tools/clipboard.lua), but with many changes and some contributions and inspiration from [asmagill](https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua).
---
--- Download: [https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ClipboardTool.spoon.zip](https://github.com/Hammerspoon/Spoons/raw/master/Spoons/ClipboardTool.spoon.zip)
--- selene: allow(undefined_variable)
--
local obj = {}
obj.__index = obj

-- Metadata
obj.name = "ClipboardToolSqlite"
obj.version = "0.7"
obj.author = "Alfred Schilken <alfred@schilken.de>"
obj.homepage = "https://github.com/Hammerspoon/Spoons"
obj.license = "MIT - https://opensource.org/licenses/MIT"

local getSetting = function(label, default)
  return hs.settings.get(obj.name .. "." .. label) or default
end
local setSetting = function(label, value)
  hs.settings.set(obj.name .. "." .. label, value)
  return value
end

--- ClipboardTool.frequency
--- Variable
--- Speed in seconds to check for clipboard changes. If you check too frequently, you will degrade performance, if you check sparsely you will loose copies. Defaults to 0.8.
obj.frequency = 0.8

--- ClipboardTool.hist_size
--- Variable
--- How many items to keep on history. Defaults to 100
obj.hist_size = 25

--- ClipboardTool.honor_ignoredidentifiers
--- Variable
--- If `true`, check the data identifiers set in the pasteboard and ignore entries which match those listed in `ClipboardTool.ignoredIdentifiers`. The list of identifiers comes from http://nspasteboard.org. Defaults to `true`
obj.honor_ignoredidentifiers = true

--- ClipboardTool.ignoredIdentifiers
--- Variable
--- Types of clipboard entries to ignore, see http://nspasteboard.org. Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua. Default value (don't modify unless you know what you are doing):
--- ```
---  {
---     ["de.petermaurer.TransientPasteboardType"] = true, -- Transient : Textpander, TextExpander, Butler
---     ["com.typeit4me.clipping"]                 = true, -- Transient : TypeIt4Me
---     ["Pasteboard generator type"]              = true, -- Transient : Typinator
---     ["com.agilebits.onepassword"]              = true, -- Confidential : 1Password
---     ["org.nspasteboard.TransientType"]         = true, -- Universal, Transient
---     ["org.nspasteboard.ConcealedType"]         = true, -- Universal, Concealed
---     ["org.nspasteboard.AutoGeneratedType"]     = true, -- Universal, Automatic
---  }
--- ```
obj.ignoredIdentifiers = {
  ["de.petermaurer.TransientPasteboardType"] = true, -- Transient : Textpander, TextExpander, Butler
  ["com.typeit4me.clipping"] = true, -- Transient : TypeIt4Me
  ["Pasteboard generator type"] = true, -- Transient : Typinator
  ["com.agilebits.onepassword"] = true, -- Confidential : 1Password
  ["org.nspasteboard.TransientType"] = true, -- Universal, Transient
  ["org.nspasteboard.ConcealedType"] = true, -- Universal, Concealed
  ["org.nspasteboard.AutoGeneratedType"] = true, -- Universal, Automatic
}

--- ClipboardTool.deduplicate
--- Variable
--- Whether to remove duplicates from the list, keeping only the latest one. Defaults to `true`.
obj.deduplicate = true

-- Maximum size of paste entry to display
obj.maxSizeEntryDisplay = 200

----------------------------------------------------------------------

-- Internal variable - Chooser/menu object
obj.selectorobj = nil

-- Internal variable - Cache for focused window to work around the current window losing focus after the chooser comes up
obj.prevFocusedWindow = nil

-- Internal variable - Timer object to look for pasteboard changes
obj.timer = nil
obj.timer_store_cleanup = nil

--

-- DATASTORE for pasteboard history
obj.store = nil
obj.sqlite_insert_stmt = nil

local pasteboard = require("hs.pasteboard") -- http://www.hammerspoon.org/docs/hs.pasteboard.html
local hashfn = require("hs.hash").MD5
local sqlite = require("hs.sqlite3")

-- Keep track of last change counter
local last_change = nil
-- Array to store the clipboard history
local clipboard_history = nil

-- Internal function - persist the current history so it survives across restarts
function _persistHistory()
  setSetting("items", clipboard_history)
end

-- Internal method - process the selected item from the chooser. An item may invoke special actions, defined in the `actions` variable.
function obj:pasteSelectedItem(value)
  if self.prevFocusedWindow ~= nil then
    self.prevFocusedWindow:focus()
  end

  -- Fetch content of sqlite3 DB to paste the complete blob
  local stmt = self.store:prepare("SELECT content FROM pasteboard where id = ?")
  stmt:bind_values(value.storeId)
  stmt:step()
  local row = stmt:get_named_values()

  last_change = pasteboard.changeCount()
  pasteboard.setContents(row.content)

  -- Does it look like JSON and are we in iterm? Then paste formatted via jq.
  -- ["", {"", [\n{
  if
    hs.application.frontmostApplication():bundleID() == "com.googlecode.iterm2"
    and (row.content:match('^%s*[{[]%s*"%a+') or row.content:match('%[%s*{%s*"'))
  then
    hs.eventtap.keyStrokes("pbpaste | jq")
    hs.eventtap.keyStroke({}, "return")
  else
    hs.eventtap.keyStroke({ "cmd" }, "v")
  end
end

-- Internal method: deduplicate the given list, and restrict it to the history size limit
function obj:dedupe_and_resize(list)
  local res = {}
  local hashes = {}
  for _, v in ipairs(list) do
    if #res < self.hist_size and v.content ~= nil then
      local hash = hashfn(v.content)
      if (not self.deduplicate) or not hashes[hash] then
        table.insert(res, v)
        hashes[hash] = true
      end
    end
  end
  return res
end

function obj:cleanup_store_handler()
  local stmt_delete = self.store:prepare("DELETE FROM pasteboard WHERE id = ?")
  local stmt = self.store:prepare("SELECT COUNT(*) AS number_rows FROM pasteboard")

  stmt:step()
  local row = stmt:get_named_values()
  stmt:reset()

  -- > 5 MB length already?
  -- More than hist_size entries?
  if row.number_rows > self.hist_size then
    -- Get the oldest N entries
    stmt = self.store:prepare("SELECT id FROM pasteboard ORDER BY id ASC LIMIT ?")
    stmt:bind_values(row.number_rows - self.hist_size + 1)
    stmt:step()

    -- Delete those rows
    for id_row in stmt:nrows() do
      stmt_delete:bind_values(id_row.id)
      stmt_delete:step()
      stmt_delete:reset()
    end
  end
end

--- ClipboardTool:pasteboardToClipboard(item)
--- Method
--- Add the given string to the history
---
--- Parameters:
---  * item - string to add to the clipboard history
---
--- Returns:
---  * None
function obj:pasteboardToClipboard(item)
  -- Adds only a small part of the complete COPY to the chooser to reduce calling size
  local clipboard_string = item
  if #item > self.maxSizeEntryDisplay then
    clipboard_string = string.sub(item, 1, self.maxSizeEntryDisplay)
      .. "... \n[+"
      .. (#item - self.maxSizeEntryDisplay)
      .. " bytes more]"
  end

  -- Save the short content (for display in the chooser and the id to reference sqlite later when pasting)
  local insert_table = {
    ["content"] = clipboard_string,
    ["id"] = os.time(),
  }
  table.insert(clipboard_history, 1, insert_table)

  -- Insert the full COPY to the store
  self.sqlite_insert_stmt:bind_values(os.time(), item, #item)
  self.sqlite_insert_stmt:step()
  self.sqlite_insert_stmt:reset()

  clipboard_history = self:dedupe_and_resize(clipboard_history)
  _persistHistory() -- updates the saved history
end

-- Internal method: actions of the context menu, delete or rearrange of clips
function obj:manageClip(row, action)
  if action == 0 then
    table.remove(clipboard_history, row)
  elseif action == 2 then
    local i = 1
    local j = row
    while i < j do
      clipboard_history[i], clipboard_history[j] = clipboard_history[j], clipboard_history[i]
      i = i + 1
      j = j - 1
    end
  else
    local value = clipboard_history[row]
    local new = row + action
    if new < 1 then
      new = 1
    end
    if new < row then
      table.move(clipboard_history, new, row - 1, new + 1)
    else
      table.move(clipboard_history, row + 1, new, row)
    end
    clipboard_history[new] = value
  end
  self.selectorobj:refreshChoicesCallback()
end

-- Internal function - fill in the chooser options, including the control options
function obj:_populateChooser()
  local menuData = {}

  for _, v in pairs(clipboard_history) do
    table.insert(menuData, {
      text = hs.styledtext.new(v.content, {
        paragraphStyle = { maximumLineHeight = 15 },
        font = { name = "InconsolataGo Nerd Font Complete Mono", size = 14 },
        color = hs.drawing.color.definedCollections.hammerspoon.black,
      }),
      subText = "",
      storeId = v.id,
    })
  end
  return menuData
end

--- ClipboardTool:shouldBeStored()
--- Method
--- Verify whether the pasteboard contents matches one of the values in `ClipboardTool.ignoredIdentifiers`
function obj:shouldBeStored()
  -- Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua
  local goAhead = true
  for _, v in ipairs(hs.pasteboard.pasteboardTypes()) do
    if self.ignoredIdentifiers[v] then
      goAhead = false
      break
    end
  end
  if goAhead then
    for _, v in ipairs(hs.pasteboard.contentTypes()) do
      if self.ignoredIdentifiers[v] then
        goAhead = false
        break
      end
    end
  end
  return goAhead
end

--- ClipboardTool:checkAndStorePasteboard()
--- Method
--- If the pasteboard has changed, we add the current item to our history and update the counter
function obj:checkAndStorePasteboard()
  local now = pasteboard.changeCount()
  if now > last_change then
    if (not self.honor_ignoredidentifiers) or self:shouldBeStored() then
      local current_clipboard = pasteboard.getContents()

      -- Do not add whitespace only and no images
      if
        current_clipboard ~= nil
        and (string.match(current_clipboard, "^%s+$") == nil)
        and (pasteboard.readImage() == nil)
      then
        self:pasteboardToClipboard(current_clipboard)
      end
    end
    last_change = now
  end
end

--- ClipboardTool:start()
--- Method
--- Start the clipboard history collector
function obj:start()
  clipboard_history = self:dedupe_and_resize(getSetting("items", {}))
  last_change = pasteboard.changeCount()

  -- Build the chooser
  self.selectorobj = hs.chooser.new(hs.fnutils.partial(self.pasteSelectedItem, self))
  self.selectorobj:choices(hs.fnutils.partial(self._populateChooser, self))

  -- Checks for changes on the pasteboard.
  self.timer = hs.timer.new(self.frequency, hs.fnutils.partial(self.checkAndStorePasteboard, self))
  self.timer:start()

  -- Check database size every <n> seconds
  self.timer_store_cleanup = hs.timer.new(20, hs.fnutils.partial(self.cleanup_store_handler, self))
  self.timer_store_cleanup:start()

  --- Initialize storage
  self.store = sqlite.open("/tmp/ClipboardToolSqlite.sqlite3")
  self.store:exec([[CREATE TABLE pasteboard (id INT, content BLOB, content_length INT);]])
  self.sqlite_insert_stmt = self.store:prepare([[INSERT INTO pasteboard VALUES(?, ?, ?);]])
end

--- ClipboardTool:showClipboard()
--- Method
--- Display the current clipboard list in a chooser
function obj:showClipboard()
  if self.selectorobj ~= nil then
    self.selectorobj:refreshChoicesCallback()
    self.prevFocusedWindow = hs.window.focusedWindow()
    self.selectorobj:show()
  else
    hs.notify.show("ClipboardTool not properly initialized", "Did you call ClipboardToolSqlite:start()?", "")
  end
end

--- ClipboardTool:bindHotkeys(mapping)
--- Method
--- Binds hotkeys for ClipboardTool
---
--- Parameters:
---  * mapping - A table containing hotkey obj/key details for the following items:
function obj:bindHotkeys(mapping)
  local def = {
    show_clipboard = hs.fnutils.partial(self.showClipboard, self),
  }
  hs.spoons.bindHotkeysToSpec(def, mapping)
  obj.mapping = mapping
end

return obj
